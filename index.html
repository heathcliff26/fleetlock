
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/fleetlock/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/heathcliff26/fleetlock/pkg/cmd/root.go (20.0%)</option>
				
				<option value="file2">github.com/heathcliff26/fleetlock/pkg/config/config.go (100.0%)</option>
				
				<option value="file3">github.com/heathcliff26/fleetlock/pkg/config/errors.go (50.0%)</option>
				
				<option value="file4">github.com/heathcliff26/fleetlock/pkg/lock-manager/config.go (100.0%)</option>
				
				<option value="file5">github.com/heathcliff26/fleetlock/pkg/lock-manager/errors/errors.go (71.4%)</option>
				
				<option value="file6">github.com/heathcliff26/fleetlock/pkg/lock-manager/manager.go (96.9%)</option>
				
				<option value="file7">github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/etcd/storage.go (79.1%)</option>
				
				<option value="file8">github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/memory/storage.go (84.6%)</option>
				
				<option value="file9">github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/redis/loadbalancer.go (100.0%)</option>
				
				<option value="file10">github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/redis/storage.go (84.1%)</option>
				
				<option value="file11">github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/sql/mysql.go (91.7%)</option>
				
				<option value="file12">github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/sql/postgres.go (83.3%)</option>
				
				<option value="file13">github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/sql/sqlite.go (83.3%)</option>
				
				<option value="file14">github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/sql/storage.go (72.9%)</option>
				
				<option value="file15">github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/sql/util.go (90.0%)</option>
				
				<option value="file16">github.com/heathcliff26/fleetlock/pkg/server/config.go (100.0%)</option>
				
				<option value="file17">github.com/heathcliff26/fleetlock/pkg/server/errors.go (0.0%)</option>
				
				<option value="file18">github.com/heathcliff26/fleetlock/pkg/server/server.go (85.9%)</option>
				
				<option value="file19">github.com/heathcliff26/fleetlock/pkg/server/utils.go (76.9%)</option>
				
				<option value="file20">github.com/heathcliff26/fleetlock/pkg/version/version.go (73.7%)</option>
				
				<option value="file21">github.com/heathcliff26/fleetlock/tests/storage/testsuite.go (98.2%)</option>
				
				<option value="file22">github.com/heathcliff26/fleetlock/tests/utils/container.go (73.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import "github.com/heathcliff26/fleetlock/pkg/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/heathcliff26/fleetlock/pkg/config"
        "github.com/heathcliff26/fleetlock/pkg/server"
        "github.com/heathcliff26/fleetlock/pkg/version"
        "github.com/spf13/cobra"
)

func NewRootCommand() *cobra.Command <span class="cov8" title="1">{
        cobra.AddTemplateFunc(
                "ProgramName", func() string </span><span class="cov0" title="0">{
                        return version.Name
                }</span>,
        )

        <span class="cov8" title="1">rootCmd := &amp;cobra.Command{
                Use:   version.Name,
                Short: version.Name + " runs a fleetlock server for use in coordinating Fedora CoreOS node updates.",
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        cfg, err := cmd.Flags().GetString("config")
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">env, err := cmd.Flags().GetBool("env")
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">run(cmd, cfg, env)
                        return nil</span>
                },
        }

        <span class="cov8" title="1">rootCmd.Flags().StringP("config", "c", "", "Path to config file")
        rootCmd.Flags().Bool("env", false, "Expand enviroment variables in config file")
        rootCmd.AddCommand(
                version.NewCommand(),
        )

        return rootCmd</span>
}

func Execute() <span class="cov0" title="0">{
        cmd := NewRootCommand()
        err := cmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                exitError(cmd, err)
        }</span>
}

func run(cmd *cobra.Command, configPath string, env bool) <span class="cov0" title="0">{
        cfg, err := config.LoadConfig(configPath, env)
        if err != nil </span><span class="cov0" title="0">{
                exitError(cmd, fmt.Errorf("failed to load configuration: %w", err))
        }</span>

        <span class="cov0" title="0">s, err := server.NewServer(cfg.Server, cfg.Groups, cfg.Storage)
        if err != nil </span><span class="cov0" title="0">{
                exitError(cmd, fmt.Errorf("failed to create server: %w", err))
        }</span>
        <span class="cov0" title="0">err = s.Run()
        if err != nil </span><span class="cov0" title="0">{
                exitError(cmd, fmt.Errorf("failed to run server: %w", err))
        }</span>
}

// Print the error information on stderr and exit with code 1
func exitError(cmd *cobra.Command, err error) <span class="cov0" title="0">{
        fmt.Fprintln(cmd.Root().ErrOrStderr(), "Fatal: "+err.Error())
        os.Exit(1)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "log/slog"
        "os"
        "strings"

        lockmanager "github.com/heathcliff26/fleetlock/pkg/lock-manager"
        "github.com/heathcliff26/fleetlock/pkg/server"
        "gopkg.in/yaml.v3"
)

const (
        DEFAULT_LOG_LEVEL = "info"
)

var logLevel = &amp;slog.LevelVar{}

// Initialize the logger
func init() <span class="cov8" title="1">{
        logLevel = &amp;slog.LevelVar{}
        opts := slog.HandlerOptions{
                Level: logLevel,
        }
        logger := slog.New(slog.NewTextHandler(os.Stdout, &amp;opts))
        slog.SetDefault(logger)
}</span>

type Config struct {
        LogLevel string                     `yaml:"logLevel,omitempty"`
        Server   *server.ServerConfig       `yaml:"server,omitempty"`
        Storage  *lockmanager.StorageConfig `yaml:"storage,omitempty"`
        Groups   lockmanager.Groups         `yaml:"groups,omitempty"`
}

// Parse a given string and set the resulting log level
func setLogLevel(level string) error <span class="cov8" title="1">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov8" title="1">
                logLevel.Set(slog.LevelDebug)</span>
        case "info":<span class="cov8" title="1">
                logLevel.Set(slog.LevelInfo)</span>
        case "warn":<span class="cov8" title="1">
                logLevel.Set(slog.LevelWarn)</span>
        case "error":<span class="cov8" title="1">
                logLevel.Set(slog.LevelError)</span>
        default:<span class="cov8" title="1">
                return NewErrUnknownLogLevel(level)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                LogLevel: DEFAULT_LOG_LEVEL,
                Server:   server.NewDefaultServerConfig(),
                Storage:  lockmanager.NewDefaultStorageConfig(),
        }
}</span>

// Loads the config from the given path.
// When path is empty, returns default config.
// Returns error when the given config is invalid.
func LoadConfig(path string, env bool) (*Config, error) <span class="cov8" title="1">{
        c := DefaultConfig()

        if path == "" </span><span class="cov8" title="1">{
                c.Defaults()
                return c, nil
        }</span>

        <span class="cov8" title="1">f, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if env </span><span class="cov8" title="1">{
                f = []byte(os.ExpandEnv(string(f)))
        }</span>

        <span class="cov8" title="1">err = yaml.Unmarshal(f, &amp;c)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">c.Defaults()

        err = c.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return c, nil</span>
}

func (c *Config) Defaults() <span class="cov8" title="1">{
        c.Server.Defaults()
        if c.Groups == nil </span><span class="cov8" title="1">{
                c.Groups = lockmanager.NewDefaultGroups()
        }</span>
}

func (c *Config) Validate() error <span class="cov8" title="1">{
        err := setLogLevel(c.LogLevel)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = c.Server.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = c.Groups.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

type ErrUnknownLogLevel struct {
        level string
}

func NewErrUnknownLogLevel(level string) error <span class="cov8" title="1">{
        return &amp;ErrUnknownLogLevel{
                level: level,
        }
}</span>

func (e *ErrUnknownLogLevel) Error() string <span class="cov0" title="0">{
        return "Unknown log level " + e.level
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package lockmanager

import (
        "github.com/heathcliff26/fleetlock/pkg/lock-manager/errors"
        "github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/etcd"
        "github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/redis"
        "github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/sql"
)

type StorageConfig struct {
        Type     string              `yaml:"type"`
        SQLite   *sql.SQLiteConfig   `yaml:"sqlite,omitempty"`
        Postgres *sql.PostgresConfig `yaml:"postgres,omitempty"`
        MySQL    *sql.MySQLConfig    `yaml:"mysql,omitempty"`
        Redis    *redis.RedisConfig  `yaml:"redis,omitempty"`
        Etcd     *etcd.EtcdConfig    `yaml:"etcd,omitempty"`
}

type Groups map[string]GroupConfig

type GroupConfig struct {
        Slots int `yaml:"slots"`
}

// Create a new storage config with default values
func NewDefaultStorageConfig() *StorageConfig <span class="cov8" title="1">{
        return &amp;StorageConfig{
                Type: "memory",
        }
}</span>

func NewDefaultGroups() Groups <span class="cov8" title="1">{
        groups := make(Groups, 1)
        groups["default"] = GroupConfig{
                Slots: 1,
        }
        return groups
}</span>

func (g Groups) Validate() error <span class="cov8" title="1">{
        for _, v := range g </span><span class="cov8" title="1">{
                if v.Slots &lt; 1 </span><span class="cov8" title="1">{
                        return errors.NewErrorGroupSlotsOutOfRange()
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package errors

import "fmt"

type ErrorUnknownGroup struct {
        group string
}

func NewErrorUnknownGroup(group string) error <span class="cov8" title="1">{
        return &amp;ErrorUnknownGroup{group: group}
}</span>

func (e *ErrorUnknownGroup) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("Unknown group: %s", e.group)
}</span>

type ErrorEmptyID struct{}

func (e ErrorEmptyID) Error() string <span class="cov0" title="0">{
        return "Received empty id, can't reserve a slot without an id"
}</span>

type ErrorUnkownStorageType struct {
        Type string
}

func NewErrorUnkownStorageType(t string) error <span class="cov8" title="1">{
        return &amp;ErrorUnkownStorageType{
                Type: t,
        }
}</span>

func (e *ErrorUnkownStorageType) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("Unsupported storage type \"%s\" selected", e.Type)
}</span>

type ErrorGroupSlotsOutOfRange struct{}

func NewErrorGroupSlotsOutOfRange() error <span class="cov8" title="1">{
        return ErrorGroupSlotsOutOfRange{}
}</span>

func (e ErrorGroupSlotsOutOfRange) Error() string <span class="cov0" title="0">{
        return "At least one group has not enough slots, need at least 1"
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package lockmanager

import (
        "sync"
        "time"

        "github.com/heathcliff26/fleetlock/pkg/lock-manager/errors"
        "github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/etcd"
        "github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/memory"
        "github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/redis"
        "github.com/heathcliff26/fleetlock/pkg/lock-manager/storage/sql"
        "github.com/heathcliff26/fleetlock/pkg/lock-manager/types"
)

type LockManager struct {
        groups  map[string]*lockGroup
        storage StorageBackend
}

type lockGroup struct {
        Config GroupConfig
        RWLock sync.RWMutex
}

// It is assumed that each group itself is multi-read, single-write.
// There can be multiple writes to different groups happening in parallel though.
type StorageBackend interface {
        // Reserve a lock for the given group.
        // Returns true if the lock is successfully reserved, even if the lock is already held by the specific id
        Reserve(group, id string) error
        // Returns the current number of locks for the given group
        GetLocks(group string) (int, error)
        // Release the lock currently held by the id.
        // Does not fail when no lock is held.
        Release(group, id string) error
        // Return all locks older than x
        GetStaleLocks(ts time.Duration) ([]types.Lock, error)
        // Check if a given id already has a lock for this group
        HasLock(group, id string) (bool, error)
        // Calls all necessary finalization if necessary
        Close() error
}

// Create a new LockManager from the given configuration
func NewManager(groups Groups, storageCfg *StorageConfig) (*LockManager, error) <span class="cov8" title="1">{
        var storage StorageBackend
        var err error
        switch storageCfg.Type </span>{
        case "memory":<span class="cov8" title="1">
                i := 0
                groupNames := make([]string, len(groups))
                for k := range groups </span><span class="cov8" title="1">{
                        groupNames[i] = k
                        i++
                }</span>
                <span class="cov8" title="1">storage = memory.NewMemoryBackend(groupNames)</span>
        case "sqlite":<span class="cov8" title="1">
                storage, err = sql.NewSQLiteBackend(storageCfg.SQLite)</span>
        case "postgres":<span class="cov8" title="1">
                storage, err = sql.NewPostgresBackend(storageCfg.Postgres)</span>
        case "mysql":<span class="cov8" title="1">
                storage, err = sql.NewMySQLBackend(storageCfg.MySQL)</span>
        case "redis":<span class="cov8" title="1">
                storage, err = redis.NewRedisBackend(storageCfg.Redis)</span>
        case "etcd":<span class="cov8" title="1">
                storage, err = etcd.NewEtcdBackend(storageCfg.Etcd)</span>
        default:<span class="cov8" title="1">
                err = errors.NewErrorUnkownStorageType(storageCfg.Type)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;LockManager{
                groups:  initGroups(groups),
                storage: storage,
        }, nil</span>
}

// Create a new LockManager with custom StorageBackend
func NewManagerWithStorage(groups Groups, storage StorageBackend) *LockManager <span class="cov8" title="1">{
        return &amp;LockManager{
                groups:  initGroups(groups),
                storage: storage,
        }
}</span>

func initGroups(groups Groups) map[string]*lockGroup <span class="cov8" title="1">{
        g := make(map[string]*lockGroup, len(groups))
        for name, cfg := range groups </span><span class="cov8" title="1">{
                g[name] = &amp;lockGroup{
                        Config: cfg,
                }
        }</span>
        <span class="cov8" title="1">return g</span>
}

func (lm *LockManager) Reserve(group, id string) (bool, error) <span class="cov8" title="1">{
        lGroup := lm.groups[group]
        if lGroup == nil </span><span class="cov8" title="1">{
                return false, errors.NewErrorUnknownGroup(group)
        }</span>
        <span class="cov8" title="1">if id == "" </span><span class="cov8" title="1">{
                return false, errors.ErrorEmptyID{}
        }</span>

        <span class="cov8" title="1">checkHasLock := func() (bool, error) </span><span class="cov8" title="1">{
                // Lock group for reading to ensure that no writing is happening during it and result is accurate
                lGroup.RWLock.RLock()
                defer lGroup.RWLock.RUnlock()

                return lm.storage.HasLock(group, id)
        }</span>
        <span class="cov8" title="1">ok, err := checkHasLock()
        if ok &amp;&amp; err == nil </span><span class="cov8" title="1">{
                return true, nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Use own function to ensure lock is released
        <span class="cov8" title="1">checkAvailableSlots := func() (bool, error) </span><span class="cov8" title="1">{
                // Lock group for reading to ensure that no writing is happening during it and result is accurate
                lGroup.RWLock.RLock()
                defer lGroup.RWLock.RUnlock()

                return lm.checkSlots(group, lGroup.Config)
        }</span>
        <span class="cov8" title="1">ok, err = checkAvailableSlots()
        if err != nil || !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        // Get Write Lock
        <span class="cov8" title="1">lGroup.RWLock.Lock()
        defer lGroup.RWLock.Unlock()

        // Re-check, since another write could have happened between checking the first time and now
        ok, err = lm.checkSlots(group, lGroup.Config)
        if err != nil || !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = lm.storage.Reserve(group, id)
        return err == nil, err</span>
}

func (lm *LockManager) checkSlots(group string, cfg GroupConfig) (bool, error) <span class="cov8" title="1">{
        usedSlots, err := lm.storage.GetLocks(group)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">return usedSlots &lt; cfg.Slots, nil</span>
}

func (lm *LockManager) Release(group, id string) error <span class="cov8" title="1">{
        lGroup := lm.groups[group]
        if lGroup == nil </span><span class="cov8" title="1">{
                return errors.NewErrorUnknownGroup(group)
        }</span>
        <span class="cov8" title="1">if id == "" </span><span class="cov8" title="1">{
                return errors.ErrorEmptyID{}
        }</span>

        <span class="cov8" title="1">lGroup.RWLock.Lock()
        defer lGroup.RWLock.Unlock()

        return lm.storage.Release(group, id)</span>
}

func (lm *LockManager) Close() error <span class="cov8" title="1">{
        return lm.storage.Close()
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package etcd

import (
        "context"
        "crypto/tls"
        "fmt"
        "time"

        "github.com/heathcliff26/fleetlock/pkg/lock-manager/types"
        "go.etcd.io/etcd/client/pkg/v3/transport"
        clientv3 "go.etcd.io/etcd/client/v3"
)

const keyformat = "com.github.heathcliff26.fleetlock/group/%s/id/%s"

const timeout = 200 * time.Millisecond

type EtcdBackend struct {
        client *clientv3.Client
}

type EtcdConfig struct {
        Endpoints []string `yaml:"endpoints,omitempty"`
        Username  string   `yaml:"username,omitempty"`
        Password  string   `yaml:"password,omitempty"`
        CertFile  string   `yaml:"cert,omitempty"`
        KeyFile   string   `yaml:"key,omitempty"`
}

func NewEtcdBackend(cfg *EtcdConfig) (*EtcdBackend, error) <span class="cov8" title="1">{
        var tls *tls.Config
        if cfg.CertFile != "" &amp;&amp; cfg.KeyFile != "" </span><span class="cov0" title="0">{
                var err error
                tls, err = transport.TLSInfo{
                        CertFile: cfg.CertFile,
                        KeyFile:  cfg.KeyFile,
                }.ClientConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load client certificate: %w", err)
                }</span>
        }
        <span class="cov8" title="1">c, err := clientv3.New(clientv3.Config{
                Endpoints:   cfg.Endpoints,
                Username:    cfg.Username,
                Password:    cfg.Password,
                DialTimeout: time.Second,
                TLS:         tls,
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create etcd client: %w", err)
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        _, err = c.MemberList(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ETCD client failed connection check: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;EtcdBackend{
                client: c,
        }, nil</span>
}

// Reserve a lock for the given group.
// Returns true if the lock is successfully reserved, even if the lock is already held by the specific id
func (e *EtcdBackend) Reserve(group string, id string) error <span class="cov8" title="1">{
        key := fmt.Sprintf(keyformat, group, id)
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        _, err := e.client.Txn(ctx).If(
                clientv3.Compare(clientv3.Version(key), "=", 0),
        ).Then(
                clientv3.OpPut(key, time.Now().String()),
        ).Commit()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Returns the current number of locks for the given group
func (e *EtcdBackend) GetLocks(group string) (int, error) <span class="cov8" title="1">{
        key := fmt.Sprintf(keyformat, group, "")
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        res, err := e.client.Get(ctx, key, clientv3.WithPrefix(), clientv3.WithCountOnly())
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return int(res.Count), nil</span>
}

// Release the lock currently held by the id.
// Does not fail when no lock is held.
func (e *EtcdBackend) Release(group string, id string) error <span class="cov8" title="1">{
        key := fmt.Sprintf(keyformat, group, id)
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        _, err := e.client.Delete(ctx, key)
        return err
}</span>

// Return all locks older than x
func (e *EtcdBackend) GetStaleLocks(ts time.Duration) ([]types.Lock, error) <span class="cov0" title="0">{
        panic("not implemented")</span> // TODO: Implement
}

// Check if a given id already has a lock for this group
func (e *EtcdBackend) HasLock(group string, id string) (bool, error) <span class="cov8" title="1">{
        key := fmt.Sprintf(keyformat, group, id)
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        res, err := e.client.Get(ctx, key, clientv3.WithCountOnly())
        if err != nil || res == nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return res.Count == 1, nil</span>
}

// Calls all necessary finalization if necessary
func (e *EtcdBackend) Close() error <span class="cov8" title="1">{
        return e.client.Close()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package memory

import (
        "time"

        "github.com/heathcliff26/fleetlock/pkg/lock-manager/errors"
        "github.com/heathcliff26/fleetlock/pkg/lock-manager/types"
)

type MemoryBackend struct {
        // This map will be assumed to be read-only after creation
        groups map[string]*group
}

type group struct {
        slots []lock
}

type lock struct {
        id      string
        created time.Time
}

const initialArraySize = 10

func NewMemoryBackend(groups []string) *MemoryBackend <span class="cov8" title="1">{
        g := make(map[string]*group)

        for _, groupName := range groups </span><span class="cov8" title="1">{
                // Pre-reserve some slots
                g[groupName] = &amp;group{
                        slots: make([]lock, 0, initialArraySize),
                }
        }</span>

        <span class="cov8" title="1">return &amp;MemoryBackend{
                groups: g,
        }</span>
}

// Reserve a lock for the given group.
// Returns true if the lock is successfully reserved, even if the lock is already held by the specific id
func (m *MemoryBackend) Reserve(group string, id string) error <span class="cov8" title="1">{
        g := m.groups[group]
        if g == nil </span><span class="cov0" title="0">{
                // All groups should be initialized at the beginning
                return errors.NewErrorUnknownGroup(group)
        }</span>

        <span class="cov8" title="1">if g.hasLock(id) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">lock := lock{
                id:      id,
                created: time.Now(),
        }
        g.slots = append(g.slots, lock)

        return nil</span>
}

// Returns the current number of locks for the given group
func (m *MemoryBackend) GetLocks(group string) (int, error) <span class="cov8" title="1">{
        g := m.groups[group]
        if g == nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">return len(g.slots), nil</span>
}

// Release the lock currently held by the id.
// Does not fail when no lock is held.
func (m *MemoryBackend) Release(group string, id string) error <span class="cov8" title="1">{
        g := m.groups[group]
        if g == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var i int
        var l lock
        for i, l = range g.slots </span><span class="cov8" title="1">{
                if l.id == id </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">if len(g.slots) &gt; 1 </span><span class="cov8" title="1">{
                g.slots[i] = g.slots[len(g.slots)-1]
                g.slots = g.slots[:len(g.slots)-1]
        }</span> else<span class="cov8" title="1"> {
                g.slots = g.slots[:0]
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Return all locks older than x
func (m *MemoryBackend) GetStaleLocks(ts time.Duration) ([]types.Lock, error) <span class="cov0" title="0">{
        panic("TODO")</span>
}

// Check if a given id already has a lock for this group
func (m *MemoryBackend) HasLock(group, id string) (bool, error) <span class="cov8" title="1">{
        g := m.groups[group]
        if g == nil </span><span class="cov0" title="0">{
                // All groups should be initialized at the beginning
                return false, errors.NewErrorUnknownGroup(group)
        }</span>
        <span class="cov8" title="1">return g.hasLock(id), nil</span>
}

// Calls all necessary finalization if necessary
func (m *MemoryBackend) Close() error <span class="cov8" title="1">{
        return nil
}</span>

func (g *group) hasLock(id string) bool <span class="cov8" title="1">{
        for _, lock := range g.slots </span><span class="cov8" title="1">{
                if id == lock.id </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package redis

import (
        "context"
        "net"
        "strings"
        "sync"
        "time"

        "github.com/redis/go-redis/v9"
)

const loadbalancerHealtchCheckPeriod = time.Second * 10

type loadbalancer struct {
        // List of addresses for redis endpoints
        addrs []string
        // Options for connecting to redis
        options redis.Options
        // Context to cancle health check
        ctx    context.Context
        cancel context.CancelFunc

        selected int
        rwlock   sync.RWMutex
}

// Create a new redis client with loadbalanced connections
func NewRedisClientWithLoadbalancer(addrs []string, opt *redis.Options) (*redis.Client, *loadbalancer) <span class="cov8" title="1">{
        lb := NewRedisLoadbalancer(addrs, *opt)
        lb.PeriodicHealthCheck()
        opt.Dialer = lb.Dial
        return redis.NewClient(opt), lb
}</span>

// Return a new loadbalancer for redis
func NewRedisLoadbalancer(addrs []string, opt redis.Options) *loadbalancer <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())

        if opt.Network == "" </span><span class="cov8" title="1">{
                opt.Network = "tcp"
        }</span>

        <span class="cov8" title="1">return &amp;loadbalancer{
                addrs:   addrs,
                options: opt,
                ctx:     ctx,
                cancel:  cancel,
        }</span>
}

// Determine the first healthy master node
func (lb *loadbalancer) HealthCheck() <span class="cov8" title="1">{
        for i, addr := range lb.addrs </span><span class="cov8" title="1">{
                opt := lb.options
                opt.Addr = addr
                client := redis.NewClient(&amp;opt)
                defer client.Close()

                res, err := client.Ping(context.Background()).Result()
                if err != nil || res != "PONG" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">res, err = client.Info(context.Background(), "replication").Result()
                if err == nil || strings.Contains(res, "role:master") </span><span class="cov8" title="1">{
                        lb.rwlock.Lock()
                        defer lb.rwlock.Unlock()
                        lb.selected = i
                        break</span>
                }
        }
}

// Starts go-routine that periodically runs a healthcheck in the background
func (lb *loadbalancer) PeriodicHealthCheck() <span class="cov8" title="1">{
        go lb.periodicHealthCheck()
}</span>

func (lb *loadbalancer) periodicHealthCheck() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                lb.HealthCheck()

                select </span>{
                case &lt;-lb.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-time.After(loadbalancerHealtchCheckPeriod):<span class="cov0" title="0"></span>
                }
        }
}

func (lb *loadbalancer) Dial(ctx context.Context, _ string, _ string) (net.Conn, error) <span class="cov8" title="1">{
        lb.rwlock.RLock()
        defer lb.rwlock.RUnlock()
        return net.Dial(lb.options.Network, lb.addrs[lb.selected])
}</span>

func (lb *loadbalancer) Close() <span class="cov8" title="1">{
        lb.cancel()
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package redis

import (
        "context"
        "fmt"
        "time"

        "github.com/heathcliff26/fleetlock/pkg/lock-manager/types"
        "github.com/redis/go-redis/v9"
)

const keyformat = "group:%s,id:%s"

type RedisBackend struct {
        client *redis.Client
        lb     *loadbalancer
}

type RedisConfig struct {
        Addr     string              `yaml:"address,omitempty"`
        Addrs    []string            `yaml:"addresses,omitempty"`
        Username string              `yaml:"username,omitempty"`
        Password string              `yaml:"password,omitempty"`
        DB       int                 `yaml:"db,omitempty"`
        Sentinel RedisSentinelConfig `yaml:"sentinel,omitempty"`
}

type RedisSentinelConfig struct {
        Enabled    bool     `yaml:"enabled,omitempty"`
        MasterName string   `yaml:"master,omitempty"`
        Addresses  []string `yaml:"addresses,omitempty"`
        Username   string   `yaml:"username,omitempty"`
        Password   string   `yaml:"password,omitempty"`
}

func NewRedisBackend(cfg *RedisConfig) (*RedisBackend, error) <span class="cov8" title="1">{
        var client *redis.Client
        var lb *loadbalancer
        switch </span>{
        case cfg.Sentinel.Enabled:<span class="cov8" title="1">
                client = redis.NewFailoverClient(&amp;redis.FailoverOptions{
                        MasterName:       cfg.Sentinel.MasterName,
                        SentinelAddrs:    cfg.Sentinel.Addresses,
                        SentinelUsername: cfg.Sentinel.Username,
                        SentinelPassword: cfg.Sentinel.Password,
                        Username:         cfg.Username,
                        Password:         cfg.Password,
                        DB:               cfg.DB,
                })</span>
        case len(cfg.Addrs) &gt; 0:<span class="cov8" title="1">
                opt := redis.Options{
                        Username: cfg.Username,
                        Password: cfg.Password,
                        DB:       cfg.DB,
                }
                client, lb = NewRedisClientWithLoadbalancer(cfg.Addrs, &amp;opt)</span>
        default:<span class="cov8" title="1">
                client = redis.NewClient(&amp;redis.Options{
                        Addr:     cfg.Addr,
                        Username: cfg.Username,
                        Password: cfg.Password,
                        DB:       cfg.DB,
                })</span>
        }

        <span class="cov8" title="1">err := client.Ping(context.Background()).Err()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to ping redis server: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;RedisBackend{
                client: client,
                lb:     lb,
        }, nil</span>
}

// Reserve a lock for the given group.
// Returns true if the lock is successfully reserved, even if the lock is already held by the specific id
func (r *RedisBackend) Reserve(group string, id string) error <span class="cov8" title="1">{
        key := fmt.Sprintf(keyformat, group, id)
        ctx := context.Background()

        ok, err := r.client.SetNX(ctx, key, time.Now(), 0).Result()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create key: %w", err)
        }</span>

        <span class="cov8" title="1">if ok </span><span class="cov8" title="1">{
                err := r.client.SAdd(ctx, group, key).Err()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add key to group list: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Returns the current number of locks for the given group
func (r *RedisBackend) GetLocks(group string) (int, error) <span class="cov8" title="1">{
        result := r.client.SCard(context.Background(), group)
        if err := result.Err(); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get locks from database: %w", err)
        }</span>
        <span class="cov8" title="1">return int(result.Val()), nil</span>
}

// Release the lock currently held by the id.
// Does not fail when no lock is held.
func (r *RedisBackend) Release(group string, id string) error <span class="cov8" title="1">{
        key := fmt.Sprintf(keyformat, group, id)
        ctx := context.Background()

        err := r.client.Del(ctx, key).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete key in database: %w", err)
        }</span>

        <span class="cov8" title="1">err = r.client.SRem(ctx, group, key).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove key from group: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Return all locks older than x
func (r *RedisBackend) GetStaleLocks(ts time.Duration) ([]types.Lock, error) <span class="cov0" title="0">{
        panic("not implemented")</span> // TODO: Implement
}

// Check if a given id already has a lock for this group
func (r *RedisBackend) HasLock(group string, id string) (bool, error) <span class="cov8" title="1">{
        key := fmt.Sprintf(keyformat, group, id)
        ctx := context.Background()

        count, err := r.client.Exists(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to count keys in group: %w", err)
        }</span>
        <span class="cov8" title="1">return count == 1, nil</span>
}

// Calls all necessary finalization if necessary
func (r *RedisBackend) Close() error <span class="cov8" title="1">{
        if r.lb != nil </span><span class="cov8" title="1">{
                r.lb.Close()
        }</span>
        <span class="cov8" title="1">return r.client.Close()</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package sql

import (
        "database/sql"
        "fmt"

        _ "github.com/go-sql-driver/mysql"
)

type MySQLConfig struct {
        Address  string `yaml:"address"`
        Username string `yaml:"username"`
        Password string `yaml:"password"`
        Database string `yaml:"database"`
        Options  string `yaml:"options,omitempty"`
}

func NewMySQLBackend(cfg *MySQLConfig) (*SQLBackend, error) <span class="cov8" title="1">{
        connStr := createConnectionString(cfg.Username, cfg.Password, cfg.Address, cfg.Database, cfg.Options)

        db, err := sql.Open("mysql", connStr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open mysql database: %w", err)
        }</span>

        <span class="cov8" title="1">err = db.Ping()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to ping mysql database: %w", err)
        }</span>

        <span class="cov8" title="1">s := &amp;SQLBackend{
                databaseType: "mysql",
                db:           db,
        }

        err = s.init()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize database: %w", err)
        }</span>
        <span class="cov8" title="1">return s, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package sql

import (
        "database/sql"
        "fmt"

        _ "github.com/jackc/pgx/v5/stdlib"
)

const (
        postgresReserve = `INSERT INTO locks (group_name, id, created)
                SELECT $1,$2,$3
                WHERE NOT EXISTS (
                        SELECT 1 FROM locks WHERE group_name=$4 AND id=$5
                );`

        postgresGetLocks = `SELECT COUNT(*) FROM (
                        SELECT id FROM locks WHERE group_name=$1
                ) AS TMP;`

        postgresRelease = "DELETE FROM locks WHERE group_name=$1 AND id=$2;"

        postgresHasLock = "SELECT 1 FROM locks WHERE group_name=$1 AND id=$2;"
)

type PostgresConfig struct {
        Address  string `yaml:"address"`
        Username string `yaml:"username"`
        Password string `yaml:"password"`
        Database string `yaml:"database"`
        Options  string `yaml:"options,omitempty"`
}

func NewPostgresBackend(cfg *PostgresConfig) (*SQLBackend, error) <span class="cov8" title="1">{
        connStr := createConnectionString(cfg.Username, cfg.Password, cfg.Address, cfg.Database, cfg.Options)

        db, err := sql.Open("pgx", "postgres://"+connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open postgres database: %w", err)
        }</span>

        <span class="cov8" title="1">err = db.Ping()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to ping postgres database: %w", err)
        }</span>

        <span class="cov8" title="1">s := &amp;SQLBackend{
                databaseType: "postgres",
                db:           db,
        }

        err = s.init()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize database: %w", err)
        }</span>
        <span class="cov8" title="1">return s, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package sql

import (
        "database/sql"
        "fmt"

        _ "modernc.org/sqlite"
)

type SQLiteConfig struct {
        File string `yaml:"file"`
}

func NewSQLiteBackend(cfg *SQLiteConfig) (*SQLBackend, error) <span class="cov8" title="1">{
        db, err := sql.Open("sqlite", cfg.File)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open sqlite database: %w", err)
        }</span>

        <span class="cov8" title="1">db.SetMaxOpenConns(1)

        err = db.Ping()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to \"ping\" sqlite database: %w", err)
        }</span>

        <span class="cov8" title="1">s := &amp;SQLBackend{
                databaseType: "sqlite",
                db:           db,
        }

        err = s.init()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize database: %w", err)
        }</span>
        <span class="cov8" title="1">return s, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package sql

import (
        "database/sql"
        "fmt"
        "time"

        "github.com/heathcliff26/fleetlock/pkg/lock-manager/types"
        _ "modernc.org/sqlite"
)

const (
        stmtCreateTable = `CREATE TABLE IF NOT EXISTS locks (
        group_name VARCHAR(100) NOT NULL,
        id VARCHAR(100) NOT NULL,
        created TIMESTAMP NOT NULL,
        PRIMARY KEY (group_name,id)
        );`

        stmtReserve = `INSERT INTO locks (group_name, id, created)
                SELECT ?,?,?
                WHERE NOT EXISTS (
                        SELECT 1 FROM locks WHERE group_name=? AND id=?
                );`

        stmtGetLocks = `SELECT COUNT(*) FROM (
                        SELECT id FROM locks WHERE group_name=?
                ) AS TMP;`

        stmtRelease = "DELETE FROM locks WHERE group_name=? AND id=?;"

        stmtHasLock = "SELECT 1 FROM locks WHERE group_name=? AND id=?;"
)

type SQLBackend struct {
        databaseType string

        db *sql.DB

        reserve  *sql.Stmt
        getLocks *sql.Stmt
        release  *sql.Stmt
        hasLock  *sql.Stmt
}

func (s *SQLBackend) init() error <span class="cov8" title="1">{
        var reserve, get, release, has string
        switch s.databaseType </span>{
        case "postgres":<span class="cov8" title="1">
                reserve = postgresReserve
                get = postgresGetLocks
                release = postgresRelease
                has = postgresHasLock</span>
        default:<span class="cov8" title="1">
                reserve = stmtReserve
                get = stmtGetLocks
                release = stmtRelease
                has = stmtHasLock</span>
        }

        <span class="cov8" title="1">_, err := s.db.Exec(stmtCreateTable)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create lock table: %w", err)
        }</span>

        <span class="cov8" title="1">s.reserve, err = s.db.Prepare(reserve)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare reserve statement: %w", err)
        }</span>

        <span class="cov8" title="1">s.getLocks, err = s.db.Prepare(get)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare getLocks statement: %w", err)
        }</span>

        <span class="cov8" title="1">s.release, err = s.db.Prepare(release)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare release statement: %w", err)
        }</span>

        <span class="cov8" title="1">s.hasLock, err = s.db.Prepare(has)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare hasLock statement: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Reserve a lock for the given group.
// Returns true if the lock is successfully reserved, even if the lock is already held by the specific id
func (s *SQLBackend) Reserve(group string, id string) error <span class="cov8" title="1">{
        _, err := s.reserve.Exec(group, id, time.Now(), group, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reserve lock: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Returns the current number of locks for the given group
func (s *SQLBackend) GetLocks(group string) (int, error) <span class="cov8" title="1">{
        rows, err := s.getLocks.Query(group)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to run getLocks query: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        if !rows.Next() </span><span class="cov0" title="0">{
                err = rows.Err()
                if err != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("failed to read rows from getLocks result: %w", err)
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }

        <span class="cov8" title="1">var count int
        err = rows.Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to read next row from getLocks result: %w", err)
        }</span>
        <span class="cov8" title="1">return count, nil</span>
}

// Release the lock currently held by the id.
// Does not fail when no lock is held.
func (s *SQLBackend) Release(group string, id string) error <span class="cov8" title="1">{
        _, err := s.release.Exec(group, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to release lock: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Return all locks older than x
func (s *SQLBackend) GetStaleLocks(ts time.Duration) ([]types.Lock, error) <span class="cov0" title="0">{
        panic("TODO")</span>
}

// Check if a given id already has a lock for this group
func (s *SQLBackend) HasLock(group, id string) (bool, error) <span class="cov8" title="1">{
        rows, err := s.hasLock.Query(group, id)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to run hasLocks query: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        res := rows.Next()
        err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("failed to read rows from hasLocks result: %w", err)
        }</span>
        <span class="cov8" title="1">return res, err</span>
}

// Calls all necessary finalization if necessary
func (s *SQLBackend) Close() error <span class="cov8" title="1">{
        return s.db.Close()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package sql

func createConnectionString(username, password, address, database, options string) string <span class="cov8" title="1">{
        var connStr string
        if username != "" </span><span class="cov8" title="1">{
                connStr += username
                if password != "" </span><span class="cov8" title="1">{
                        connStr += ":" + password
                }</span>
                <span class="cov8" title="1">connStr += "@"</span>
        }
        <span class="cov8" title="1">connStr += address + "/" + database
        if options != "" </span><span class="cov0" title="0">{
                connStr += "?" + options
        }</span>

        <span class="cov8" title="1">return connStr</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package server

import (
        "strconv"
)

const (
        DEFAULT_SERVER_PORT     = 8080
        DEFAULT_SERVER_PORT_SSL = 8443
)

type ServerConfig struct {
        Listen string    `yaml:"listen"`
        SSL    SSLConfig `yaml:"ssl,omitempty"`
}

type SSLConfig struct {
        Enabled bool   `yaml:"enabled,omitempty"`
        Cert    string `yaml:"cert,omitempty"`
        Key     string `yaml:"key,omitempty"`
}

// Create a default server config with
func NewDefaultServerConfig() *ServerConfig <span class="cov8" title="1">{
        return &amp;ServerConfig{}
}</span>

// Check if there are empty values that need to be replaced by default values
func (cfg *ServerConfig) Defaults() <span class="cov8" title="1">{
        if cfg.Listen == "" </span><span class="cov8" title="1">{
                if cfg.SSL.Enabled </span><span class="cov8" title="1">{
                        cfg.Listen = ":" + strconv.Itoa(DEFAULT_SERVER_PORT_SSL)
                }</span> else<span class="cov8" title="1"> {
                        cfg.Listen = ":" + strconv.Itoa(DEFAULT_SERVER_PORT)
                }</span>
        }
}

// Validate Server config and set default listen addr if needed
func (cfg *ServerConfig) Validate() error <span class="cov8" title="1">{
        if cfg.SSL.Enabled </span><span class="cov8" title="1">{
                if cfg.SSL.Cert == "" || cfg.SSL.Key == "" </span><span class="cov8" title="1">{
                        return ErrorIncompleteSSlConfig{}
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package server

type ErrorIncompleteSSlConfig struct{}

func (e ErrorIncompleteSSlConfig) Error() string <span class="cov0" title="0">{
        return "SSL is enabled but either key or certificate is missing"
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package server

import (
        "encoding/json"
        "errors"
        "log/slog"
        "net/http"
        "regexp"
        "strings"

        lockmanager "github.com/heathcliff26/fleetlock/pkg/lock-manager"
)

const groupValidationPattern = "^[a-zA-Z0-9.-]+$"

var groupValidationRegex = regexp.MustCompile(groupValidationPattern)

type Server struct {
        cfg *ServerConfig
        lm  *lockmanager.LockManager
}

type FleetLockRequest struct {
        Client struct {
                ID    string `json:"id"`
                Group string `json:"group"`
        } `json:"client_params"`
}

type FleetLockResponse struct {
        Kind  string `json:"kind"`
        Value string `json:"value"`
}

// Create a new Server
func NewServer(cfg *ServerConfig, groups lockmanager.Groups, storageCfg *lockmanager.StorageConfig) (*Server, error) <span class="cov8" title="1">{
        lm, err := lockmanager.NewManager(groups, storageCfg)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Server{
                cfg: cfg,
                lm:  lm,
        }, nil</span>
}

// Main entrypoint for new requests
func (s *Server) requestHandler(rw http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        slog.Debug("Received request", slog.String("method", req.Method), slog.String("uri", req.RequestURI), slog.String("remote", ReadUserIP(req)))

        var handleFunc func(http.ResponseWriter, FleetLockRequest)
        switch req.URL.String() </span>{
        case "/v1/pre-reboot":<span class="cov8" title="1">
                handleFunc = s.handleReserve</span>
        case "/v1/steady-state":<span class="cov8" title="1">
                handleFunc = s.handleRelease</span>
        default:<span class="cov8" title="1">
                slog.Debug("Unknown URL", slog.String("url", req.URL.String()), slog.String("remote", ReadUserIP(req)))
                rw.WriteHeader(http.StatusNotFound)
                sendResponse(rw, msgNotFound)
                return</span>
        }

        // Verify right method
        <span class="cov8" title="1">if req.Method != http.MethodPost </span><span class="cov8" title="1">{
                slog.Debug("Received request with wrong method", slog.String("method", req.Method), slog.String("remote", ReadUserIP(req)))
                rw.WriteHeader(http.StatusMethodNotAllowed)
                sendResponse(rw, msgWrongMethod)
                return
        }</span>

        // Verify FleetLock header is set
        <span class="cov8" title="1">if strings.ToLower(req.Header.Get("fleet-lock-protocol")) != "true" </span><span class="cov8" title="1">{
                slog.Debug("Received request with missing or wrong fleet-lock-protocol header", slog.String("remote", ReadUserIP(req)))
                rw.WriteHeader(http.StatusBadRequest)
                sendResponse(rw, msgMissingFleetLockHeader)
                return
        }</span>

        <span class="cov8" title="1">var params FleetLockRequest
        err := json.NewDecoder(req.Body).Decode(&amp;params)
        if err != nil </span><span class="cov8" title="1">{
                slog.Debug("Failed to parse request", "error", err, slog.String("remote", ReadUserIP(req)))
                rw.WriteHeader(http.StatusBadRequest)
                sendResponse(rw, msgRequestParseFailed)
                return
        }</span>

        <span class="cov8" title="1">if strings.Contains(params.Client.Group, "\n") || !groupValidationRegex.MatchString(params.Client.Group) </span><span class="cov8" title="1">{
                slog.Debug("Request contained invalid characters for group", slog.String("group", params.Client.Group), slog.String("remote", ReadUserIP(req)))
                rw.WriteHeader(http.StatusBadRequest)
                sendResponse(rw, msgInvalidGroupValue)
                return
        }</span>

        <span class="cov8" title="1">if params.Client.ID == "" </span><span class="cov8" title="1">{
                slog.Debug("Request did not contain an id", slog.String("remote", ReadUserIP(req)))
                rw.WriteHeader(http.StatusBadRequest)
                sendResponse(rw, msgEmptyID)
                return
        }</span>

        <span class="cov8" title="1">handleFunc(rw, params)</span>
}

// Handle requests to reserve a slot
//
//        URL: /v1/pre-reboot
func (s *Server) handleReserve(rw http.ResponseWriter, params FleetLockRequest) <span class="cov8" title="1">{
        ok, err := s.lm.Reserve(params.Client.Group, params.Client.ID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Failed to reserve slot", "error", err, slog.String("group", params.Client.Group), slog.String("group", params.Client.ID))
                rw.WriteHeader(http.StatusInternalServerError)
                sendResponse(rw, msgUnexpectedError)
                return
        }</span>
        <span class="cov8" title="1">if ok </span><span class="cov8" title="1">{
                slog.Info("Reserved slot", slog.String("group", params.Client.Group), slog.String("group", params.Client.ID))
                sendResponse(rw, msgSuccess)
        }</span> else<span class="cov8" title="1"> {
                slog.Debug("Could not reserve slot, all slots where filled", slog.String("group", params.Client.Group), slog.String("group", params.Client.ID))
                rw.WriteHeader(http.StatusLocked)
                sendResponse(rw, msgSlotsFull)
        }</span>
}

// Handle requests to release a slot
//
//        URL: /v1/steady-state
func (s *Server) handleRelease(rw http.ResponseWriter, params FleetLockRequest) <span class="cov8" title="1">{
        err := s.lm.Release(params.Client.Group, params.Client.ID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Failed to release slot", "error", err, slog.String("group", params.Client.Group), slog.String("group", params.Client.ID))
                rw.WriteHeader(http.StatusInternalServerError)
                sendResponse(rw, msgUnexpectedError)
                return
        }</span>
        <span class="cov8" title="1">slog.Info("Released slot", slog.String("group", params.Client.Group), slog.String("group", params.Client.ID))
        sendResponse(rw, msgSuccess)</span>
}

// Starts the server and exits with error if that fails
func (s *Server) Run() error <span class="cov0" title="0">{
        http.HandleFunc("/", s.requestHandler)

        slog.Info("Starting server", slog.String("listen", s.cfg.Listen), slog.Bool("ssl", s.cfg.SSL.Enabled))

        var err error
        if s.cfg.SSL.Enabled </span><span class="cov0" title="0">{
                err = http.ListenAndServeTLS(s.cfg.Listen, s.cfg.SSL.Cert, s.cfg.SSL.Key, nil)
        }</span> else<span class="cov0" title="0"> {
                err = http.ListenAndServe(s.cfg.Listen, nil)
        }</span>
        // This just means the server was closed after running
        <span class="cov0" title="0">if errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                slog.Info("Server closed, exiting")
                return nil
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package server

import (
        "encoding/json"
        "log/slog"
        "net/http"
)

func ReadUserIP(req *http.Request) string <span class="cov8" title="1">{
        IPAddress := req.Header.Get("x-real-ip")
        if IPAddress == "" </span><span class="cov8" title="1">{
                IPAddress = req.Header.Get("x-forwarded-for")
        }</span>
        <span class="cov8" title="1">if IPAddress == "" </span><span class="cov8" title="1">{
                IPAddress = req.RemoteAddr
        }</span>
        <span class="cov8" title="1">return IPAddress</span>
}

// Send a response to the writer and handle impossible parse errors
func sendResponse(rw http.ResponseWriter, res FleetLockResponse) <span class="cov8" title="1">{
        b, err := json.Marshal(res)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to create Response", "err", err)
                return
        }</span>

        <span class="cov8" title="1">_, err = rw.Write(b)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to send response to client", "err", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package version

import (
        "fmt"
        "runtime"
        "runtime/debug"

        "github.com/spf13/cobra"
)

const Name = "fleetlock"

var version = "devel"

func NewCommand() *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Print version information and exit",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Print(Version())
                }</span>,
        }
        // Override to prevent parent function from running
        <span class="cov8" title="1">cmd.PersistentPreRun = func(cmd *cobra.Command, args []string) </span>{<span class="cov0" title="0">}</span>

        <span class="cov8" title="1">return cmd</span>
}

func Version() string <span class="cov8" title="1">{
        var commit string
        buildinfo, _ := debug.ReadBuildInfo()
        for _, item := range buildinfo.Settings </span><span class="cov0" title="0">{
                if item.Key == "vcs.revision" </span><span class="cov0" title="0">{
                        commit = item.Value
                        break</span>
                }
        }
        <span class="cov8" title="1">if len(commit) &gt; 7 </span><span class="cov0" title="0">{
                commit = commit[:7]
        }</span> else<span class="cov8" title="1"> if commit == "" </span><span class="cov8" title="1">{
                commit = "Unknown"
        }</span>

        <span class="cov8" title="1">result := Name + ":\n"
        result += "    Version: " + version + "\n"
        result += "    Commit:  " + commit + "\n"
        result += "    Go:      " + runtime.Version() + "\n"

        return result</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package storage

import (
        "strconv"
        "sync"
        "testing"

        lockmanager "github.com/heathcliff26/fleetlock/pkg/lock-manager"
        "github.com/stretchr/testify/assert"
)

func GetGroups() lockmanager.Groups <span class="cov8" title="1">{
        testGroups := make(lockmanager.Groups, 7)
        testGroups["basic"] = lockmanager.GroupConfig{
                Slots: 1,
        }
        testGroups["NoDuplicates"] = lockmanager.GroupConfig{
                Slots: 3,
        }
        testGroups["GetLocks"] = lockmanager.GroupConfig{
                Slots: 10,
        }
        testGroups["ConcurrentReserve"] = lockmanager.GroupConfig{
                Slots: 10,
        }
        testGroups["ConcurrentRelease"] = lockmanager.GroupConfig{
                Slots: 10,
        }
        testGroups["ReserveRace"] = lockmanager.GroupConfig{
                Slots: 5,
        }
        testGroups["ReserveReturnTrueIfAlreadyExists"] = lockmanager.GroupConfig{
                Slots: 1,
        }
        return testGroups
}</span>

func RunLockManagerTestsuiteWithStorage(t *testing.T, storage lockmanager.StorageBackend) <span class="cov8" title="1">{
        lm := lockmanager.NewManagerWithStorage(GetGroups(), storage)
        t.Cleanup(func() </span><span class="cov8" title="1">{
                err := lm.Close()
                if err != nil </span><span class="cov0" title="0">{
                        t.Logf("Failed to close manager: %v", err)
                }</span>
        })

        <span class="cov8" title="1">t.Run("Basic", func(t *testing.T) </span><span class="cov8" title="1">{
                t.Run("Reserve", func(t *testing.T) </span><span class="cov8" title="1">{
                        assert := assert.New(t)

                        ok, err := lm.Reserve("basic", "User1")
                        assert.True(ok)
                        assert.Nil(err)

                        ok, err = lm.Reserve("basic", "User2")
                        assert.False(ok)
                        assert.Nil(err)
                }</span>)
                <span class="cov8" title="1">t.Run("Release", func(t *testing.T) </span><span class="cov8" title="1">{
                        assert := assert.New(t)

                        err := lm.Release("basic", "User1")
                        assert.Nil(err)

                        err = lm.Release("basic", "User1")
                        assert.Nil(err)

                        err = lm.Release("basic", "UnkownUser")
                        assert.Nil(err)
                }</span>)
        })
        <span class="cov8" title="1">t.Run("NoDuplicates", func(t *testing.T) </span><span class="cov8" title="1">{
                assert := assert.New(t)
                for range 10 </span><span class="cov8" title="1">{
                        ok, err := lm.Reserve("NoDuplicates", "same-id")
                        assert.True(ok)
                        assert.Nil(err)

                        count, err := storage.GetLocks("NoDuplicates")
                        assert.Equal(1, count)
                        assert.Nil(err)
                }</span>
        })
        <span class="cov8" title="1">t.Run("GetLocks", func(t *testing.T) </span><span class="cov8" title="1">{
                assert := assert.New(t)

                res, err := storage.GetLocks("GetLocks")
                assert.Equal(0, res)
                assert.Nil(err)

                for i := range 10 </span><span class="cov8" title="1">{
                        ok, err := lm.Reserve("GetLocks", "User"+strconv.Itoa(i))
                        assert.True(ok)
                        assert.Nil(err)

                        res, err := storage.GetLocks("GetLocks")
                        assert.Equal(i+1, res)
                        assert.Nil(err)
                }</span>
                <span class="cov8" title="1">for i := range 10 </span><span class="cov8" title="1">{
                        err := lm.Release("GetLocks", "User"+strconv.Itoa(i))
                        assert.Nil(err)

                        res, err := storage.GetLocks("GetLocks")
                        assert.Equal(9-i, res)
                        assert.Nil(err)
                }</span>
        })
        <span class="cov8" title="1">t.Run("ConcurrentReserve", func(t *testing.T) </span><span class="cov8" title="1">{
                assert := assert.New(t)

                var wg sync.WaitGroup
                wg.Add(10)
                for i := range 10 </span><span class="cov8" title="1">{
                        go func() </span><span class="cov8" title="1">{
                                defer wg.Done()
                                ok, err := lm.Reserve("ConcurrentReserve", "User"+strconv.Itoa(i))
                                assert.True(ok)
                                assert.Nil(err)
                        }</span>()
                }
                <span class="cov8" title="1">wg.Wait()

                res, err := storage.GetLocks("ConcurrentReserve")
                assert.Equal(10, res)
                assert.Nil(err)</span>
        })
        <span class="cov8" title="1">t.Run("ConcurrentRelease", func(t *testing.T) </span><span class="cov8" title="1">{
                assert := assert.New(t)
                for i := range 10 </span><span class="cov8" title="1">{
                        ok, err := lm.Reserve("ConcurrentRelease", "User"+strconv.Itoa(i))
                        if !assert.True(ok) || !assert.Nil(err) </span><span class="cov0" title="0">{
                                t.FailNow()
                        }</span>
                }

                <span class="cov8" title="1">var wg sync.WaitGroup
                wg.Add(10)
                for i := range 10 </span><span class="cov8" title="1">{
                        go func() </span><span class="cov8" title="1">{
                                defer wg.Done()
                                err := lm.Release("ConcurrentRelease", "User"+strconv.Itoa(i))
                                assert.Nil(err)
                        }</span>()
                }
                <span class="cov8" title="1">wg.Wait()

                res, err := storage.GetLocks("ConcurrentRelease")
                assert.Equal(0, res)
                assert.Nil(err)</span>
        })
        <span class="cov8" title="1">t.Run("ReserveRace", func(t *testing.T) </span><span class="cov8" title="1">{
                assert := assert.New(t)

                result := make(chan bool, 10)
                for i := range 10 </span><span class="cov8" title="1">{
                        go func() </span><span class="cov8" title="1">{
                                ok, err := lm.Reserve("ReserveRace", "User"+strconv.Itoa(i))
                                assert.Nil(err)
                                result &lt;- ok
                        }</span>()
                }
                <span class="cov8" title="1">count := 0
                for range 10 </span><span class="cov8" title="1">{
                        if &lt;-result </span><span class="cov8" title="1">{
                                count++
                        }</span>
                }
                <span class="cov8" title="1">assert.Equal(5, count)

                count, err := storage.GetLocks("ReserveRace")
                assert.Equal(5, count)
                assert.Nil(err)</span>
        })
        <span class="cov8" title="1">t.Run("ReserveReturnTrueIfAlreadyExists", func(t *testing.T) </span><span class="cov8" title="1">{
                assert := assert.New(t)

                ok, err := lm.Reserve("ReserveReturnTrueIfAlreadyExists", "User1")
                assert.True(ok)
                assert.Nil(err)

                ok, err = lm.Reserve("ReserveReturnTrueIfAlreadyExists", "User1")
                assert.True(ok)
                assert.Nil(err)
        }</span>)
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package utils

import (
        "fmt"
        "os/exec"
)

var (
        containerRuntime string
        initialized      = false
)

func findContainerRuntime() string <span class="cov8" title="1">{
        for _, cmd := range []string{"podman", "docker"} </span><span class="cov8" title="1">{
                path, err := exec.LookPath(cmd)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">err = exec.Command(path, "ps").Run()
                if err == nil </span><span class="cov8" title="1">{
                        fmt.Printf("Found container runtime %s, path=%s\n", cmd, path)
                        return path
                }</span>
        }
        <span class="cov0" title="0">fmt.Println("Did not find any container runtimes")
        return ""</span>
}

func HasContainerRuntimer() bool <span class="cov8" title="1">{
        if !initialized </span><span class="cov8" title="1">{
                containerRuntime = findContainerRuntime()
                initialized = true
        }</span>
        <span class="cov8" title="1">return containerRuntime != ""</span>
}

func GetCommand(args ...string) *exec.Cmd <span class="cov8" title="1">{
        return exec.Command(containerRuntime, args...)
}</span>

func ExecCRI(args ...string) error <span class="cov8" title="1">{
        if !initialized </span><span class="cov0" title="0">{
                containerRuntime = findContainerRuntime()
                initialized = true
        }</span>
        <span class="cov8" title="1">return GetCommand(args...).Run()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
